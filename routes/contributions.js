const express = require('express');
const router = express.Router();
const Contribution = require('../models/Contribution');
const Transaction = require('../models/Transaction');
const User = require('../models/User');
const AuditLog = require('../models/AuditLog');
const upload = require('../services/uploadService');
const jwt = require('jsonwebtoken');
const SystemSettings = require('../models/SystemSettings');
const { isAdmin } = require('../middlewares/authMiddleware');

// Middleware to check auth (simplified)
const auth = (req, res, next) => {
    // In real app, verify JWT here
    // For now, we rely on frontend sending headers or cookies
    next();
};

// Get Public Settings (Contribution Amount & Bank Details)
router.get('/settings', async (req, res) => {
    try {
        const settings = await SystemSettings.getSettings();
        res.json({
            success: true,
            data: {
                contribution_amount: settings.contribution_amount,
                bank_name: settings.bank_name,
                account_number: settings.account_number,
                account_name: settings.account_name
            }
        });
    } catch (e) {
        res.status(500).json({ detail: e.message });
    }
});

// Generate Monthly Contributions (Admin)
router.post('/generate-monthly', isAdmin, async (req, res) => {
    try {
        const today = new Date();
        const month = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;
        const users = await User.find({ role: { $ne: 'SuperAdmin' }, is_active: true });

        const settings = await SystemSettings.getSettings();
        const amount = settings.contribution_amount || 1000;

        let count = 0;
        for (const user of users) {
            const exists = await Contribution.findOne({ user_id: user._id, month });
            if (!exists) {
                await Contribution.create({
                    user_id: user._id,
                    month,
                    year: today.getFullYear(),
                    amount_due: amount,
                    status: 'Due', // Explicitly set to 'Due' for visibility
                    due_date: new Date(today.getFullYear(), today.getMonth() + 1, 5) // 5th of next month
                });
                count++;
            }
        }

        await AuditLog.create({
            actor_id: "ADMIN", // Replace with actual user ID from token
            action: "GENERATE_CONTRIBUTIONS",
            resource: "contributions",
            details: { count, month }
        });

        res.json({ success: true, message: `Generated ${count} contributions for ${month}`, data: { count, month } });
    } catch (e) {
        res.status(500).json({ detail: e.message });
    }
});

// My Contribution Status Summary (Month-by-Month)
router.get('/status-summary', async (req, res) => {
    try {
        const authHeader = req.headers.authorization;
        const token = authHeader?.split(' ')[1];
        if (!token) return res.status(401).json({ detail: 'Token missing' });
        const decoded = jwt.verify(token, process.env.JWT_SECRET);

        const queryYear = req.query.year ? parseInt(req.query.year) : new Date().getFullYear();
        const currentYear = new Date().getFullYear();
        const currentMonthIdx = new Date().getMonth(); // 0-11

        // Find all CONTRIBUTION RECORDS for this user this year (generated by admin)
        const contributions = await Contribution.find({
            user_id: decoded.id,
            year: queryYear
        });

        // Find all TRANSACTION records for this user this year (payment submissions)
        const transactions = await Transaction.find({
            user_id: decoded.id,
            type: 'Contribution',
            created_at: { $gte: new Date(queryYear, 0, 1), $lt: new Date(queryYear + 1, 0, 1) }
        });

        // Map status for each month - check contributions first, then transactions
        const months = ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        const summary = months.map(m => {
            const monthStr = `${queryYear}-${m}`;
            const monthIdx = parseInt(m) - 1;

            // Check if Contribution record exists and is marked as Paid
            const contribution = contributions.find(c => c.month === monthStr);
            if (contribution && contribution.status === 'Paid') {
                return { month: monthStr, status: 'Paid', amount: contribution.amount_due };
            }

            // Check if there's a verified transaction for this month
            const verifiedTx = transactions.find(t =>
                (t.months && t.months.includes(monthStr)) || t.month === monthStr
            );
            if (verifiedTx && verifiedTx.status === 'Verified') {
                return { month: monthStr, status: 'Paid', amount: 1000 };
            }

            // Check if there's a pending transaction for this month
            const pendingTx = transactions.find(t =>
                ((t.months && t.months.includes(monthStr)) || t.month === monthStr) && t.status === 'Pending'
            );
            if (pendingTx) {
                return { month: monthStr, status: 'Pending', amount: 1000 };
            }

            // Determine if the month is in the past or current month
            // A month is "Due" if it's the current year and current month or earlier,
            // OR if it's a past year entirely. Future years/months are "Unpaid".
            const isPastOrCurrent = (queryYear < currentYear) || (queryYear === currentYear && monthIdx <= currentMonthIdx);

            // Only past or current months can be "Due"
            if (isPastOrCurrent) {
                return { month: monthStr, status: 'Due', amount: contribution ? contribution.amount_due : 1000 };
            }

            // Future months are always "Unpaid" (even if a contribution record was generated)
            return { month: monthStr, status: 'Unpaid', amount: null };
        });

        res.json({ success: true, data: summary });
    } catch (e) {
        console.error('Status Summary Error:', e.message);
        res.status(500).json({ detail: e.message });
    }
});

// My Contributions & Stats
router.get('/my-stats', async (req, res) => {
    try {
        const authHeader = req.headers.authorization;
        const token = authHeader?.split(' ')[1];
        if (!token) return res.status(401).json({ detail: 'Token missing' });
        const decoded = jwt.verify(token, process.env.JWT_SECRET);

        // Sum all verified contribution transactions
        const transactions = await Transaction.find({
            user_id: decoded.id,
            status: 'Verified',
            type: 'Contribution'
        });

        const totalPaid = transactions.reduce((acc, curr) => acc + (curr.amount || 0), 0);

        res.json({ success: true, data: { totalPaid, count: transactions.length } });
    } catch (e) {
        console.error('My Stats Error:', e.message);
        res.status(500).json({ detail: e.message });
    }
});

// My Contributions List
router.get('/my-history', async (req, res) => {
    try {
        const authHeader = req.headers.authorization;
        const token = authHeader?.split(' ')[1];
        const decoded = jwt.verify(token, process.env.JWT_SECRET);

        const history = await Transaction.find({ user_id: decoded.id }).sort({ created_at: -1 });
        res.json({ success: true, data: history });
    } catch (e) {
        res.status(500).json({ detail: e.message });
    }
});

// Submit Payment Proof
router.post('/submit-payment', upload.single('proof'), async (req, res) => {
    try {
        const authHeader = req.headers.authorization;
        const token = authHeader?.split(' ')[1];
        if (!token) return res.status(401).json({ detail: 'Token missing' });
        const decoded = jwt.verify(token, process.env.JWT_SECRET);

        const { month, months, amount } = req.body;
        const proofPath = req.file.path;

        // Handle both single month and multi-month array
        let monthList = [];
        if (months) {
            monthList = Array.isArray(months) ? months : months.split(',');
        } else if (month) {
            monthList = [month];
        }

        // VALIDATION: Check for existing transactions for these months
        console.log(`[DEBUG] Duplicate check for user ${decoded.id}, months:`, monthList);
        const existingTx = await Transaction.find({
            user_id: decoded.id,
            status: { $in: ['Verified', 'Pending'] },
            $or: [
                { months: { $in: monthList } },
                { month: { $in: monthList } }
            ]
        });
        console.log(`[DEBUG] Found ${existingTx.length} existing transactions`);

        if (existingTx.length > 0) {
            // Flatten matched months to identify exactly which ones are duplicates
            const existingMonths = existingTx.flatMap(t => t.months && t.months.length ? t.months : [t.month]);
            console.log(`[DEBUG] Existing months for user:`, existingMonths);
            const duplicates = monthList.filter(m => existingMonths.includes(m));

            if (duplicates.length > 0) {
                console.log(`[DEBUG] DUPLICATE DETECTED:`, duplicates);
                return res.status(400).json({
                    detail: `Duplicate payment detected. You have already paid or have a pending verification for: ${duplicates.join(', ')}`
                });
            }
        }

        // Create Transaction as pending
        const tx = await Transaction.create({
            user_id: decoded.id,
            amount,
            type: 'Contribution',
            payment_method: 'Bank Transfer',
            category: 'Contribution',
            status: 'Pending',
            month: monthList[0], // Primary month for compatibility
            months: monthList,
            proof_url: proofPath
        });

        await AuditLog.create({
            actor_id: decoded.id,
            action: 'SUBMIT_PAYMENT_PROOF',
            resource: 'transactions',
            target_id: tx._id,
            details: { months: monthList, amount }
        });

        res.json({ message: 'Payment submitted', tx });
    } catch (e) {
        console.error('Submit Payment Error:', e.message);
        res.status(500).json({ detail: e.message });
    }
});

// Verify Payment (Admin)
router.post('/verify-payment/:id', isAdmin, async (req, res) => {
    try {
        const { status } = req.body; // 'Verified' or 'Rejected'
        const tx = await Transaction.findById(req.params.id);
        if (!tx) return res.status(404).json({ detail: "Transaction not found" });

        tx.status = status;
        tx.verified_at = new Date();
        tx.verified_by = req.user?.id;
        await tx.save();

        if (status === 'Verified') {
            const monthList = tx.months && tx.months.length > 0 ? tx.months : [tx.month];
            let totalPoints = 0;

            for (const m of monthList) {
                if (!m) continue;

                // Find or create contribution record for this month
                let contribution = await Contribution.findOne({ user_id: tx.user_id, month: m });

                if (!contribution) {
                    // If no contribution record (e.g. advance payment), create one
                    const [y, mm] = m.split('-').map(Number);
                    contribution = new Contribution({
                        user_id: tx.user_id,
                        month: m,
                        year: y,
                        amount_due: 1000,
                        due_date: new Date(y, mm, 5) // 5th of next month
                    });
                }

                contribution.status = 'Paid';
                contribution.amount_paid = 1000; // Fixed per month
                contribution.paid_at = new Date();
                await contribution.save();

                // Score Logic: 10 pts for on-time, 5 pts for late
                let points = 5;
                if (new Date() <= contribution.due_date) points = 10;
                totalPoints += points;
            }

            if (totalPoints > 0) {
                await User.findByIdAndUpdate(tx.user_id, { $inc: { contribution_score: totalPoints } });
            }
        }

        await AuditLog.create({
            actor_id: "ADMIN",
            action: `PAYMENT_${status.toUpperCase()}`,
            resource: "transactions",
            target_id: tx._id,
            details: { amount: tx.amount, months: tx.months }
        });

        res.json({ success: true, message: `Payment ${status}`, data: tx });
    } catch (e) {
        res.status(500).json({ detail: e.message });
    }
});

// Revert Payment (Admin)
router.post('/revert-payment/:id', isAdmin, async (req, res) => {
    try {
        const tx = await Transaction.findById(req.params.id);
        if (!tx) return res.status(404).json({ detail: "Transaction not found" });

        const oldStatus = tx.status;
        if (oldStatus === 'Pending') return res.status(400).json({ detail: "Transaction is already pending" });

        // Update Transaction
        tx.status = 'Pending';
        tx.verified_at = undefined;
        await tx.save();

        // Revert points and contribution status if it was verified
        if (oldStatus === 'Verified') {
            const monthList = tx.months && tx.months.length > 0 ? tx.months : [tx.month];
            let totalPointsToDeduct = 0;

            for (const m of monthList) {
                if (!m) continue;

                // Find the contribution to check due_date
                const contribution = await Contribution.findOne({ user_id: tx.user_id, month: m });
                if (contribution) {
                    // Recalculate points that were awarded: 10 if on-time, 5 if late
                    // We check against verified_at because that's when points were given
                    let pointsGiven = 5;
                    if (tx.verified_at <= contribution.due_date) pointsGiven = 10;
                    totalPointsToDeduct += pointsGiven;

                    // Revert Contribution Record
                    contribution.status = 'Due';
                    contribution.amount_paid = 0;
                    contribution.paid_at = undefined;
                    await contribution.save();
                }
            }

            if (totalPointsToDeduct > 0) {
                await User.findByIdAndUpdate(tx.user_id, { $inc: { contribution_score: -totalPointsToDeduct } });
            }
        }

        await AuditLog.create({
            actor_id: req.user?.id || "ADMIN",
            action: `PAYMENT_REVERTED`,
            resource: "transactions",
            target_id: tx._id,
            details: { amount: tx.amount, prev_status: oldStatus }
        });

        res.json({ success: true, message: "Payment approval reverted successfully", data: tx });
    } catch (e) {
        console.error('Revert Payment Error:', e.message);
        res.status(500).json({ detail: e.message });
    }
});

module.exports = router;
